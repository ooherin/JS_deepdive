<함수 선언문>

1. 함수 선언문은 이름을 생략할 수 없다. 
2. 함수 선언문은 표현식이 아닌 문이다. (변수에 할당할 수 없다. 
그러나 그렇게 보일 수 있다(함수 표현식))
3. 함수 선언문의 콘솔 결과값은 undefined가 나온다. 

let add = function sum(x,y){
    return x + y;
}
: 여기서 함수 이름은 sum, 식별자는 add
: 함수 호출시 sum이 아니라 add라는 식별자를 사용해 호출한다. 
(js는 함수선언문에서 함수 이름과 똑같은 sum이라는 식별자를 만들어 할당한다. 
위랑 다른 사례이다. )

함수의 이름(foo)은 함수 몸체 내부에서만 참조할 수 있는 식별자이다.
따라서 외부에서 함수 이름으로 함수를 호출할 수 없다.

-> 그럼에도 외부에서 함수를 호출할 수 있는 이유는?
js엔진이 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의
식별자를 함묵적으로 생성하고, 거기에 함수 객체를 할당하기 때문이다 

<함수 표현식> 
1. 함수 리터럴의 함수 이름은 생략 가능하다(식별자로 찾으므로) : 보통 생략
2. 함수 선언문은 표현식이 아닌 문인데 반해, 함수 표현식은 표현식인 문이다. 

함수는 js에서 1급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할수 있다.
let add = function(a,b){
    return a + b;
}

함수 선언문은 호이스팅에 의해 함수 선언 이전에 호출이 가능하다.
함수 표현식은 함수 호이스팅이 아닌 변수 호이스팅이 발생한다.
함수 표현식 이전에 함수를 참조하면 undefined가 발생한다.
->함수 표현식은 함수 표현식 이후에 호출해야 한다.
->함수 선언문보다 함수 표현식.

<화살표 함수>
1. 화살표 함수는 익명함수로 정의한다.
2. 생성자 함수로 사용할 수 없다. prototype 프로퍼티가 없다.
3. 기존 함수와 this바인딩 방식이 다르다.
4. arguments객체를 생성하지 않는다.

함수를 호출할 때 인수가 부족하면 나오는 값은 undefined이다.
함수를 호출할 떄 인수가 초과되면 초과된 인수는 무시된다.

arguments객체는 함수를 정의할 때 매개변수 개수를 확정할 수 없는
가변 인자 함수를 구현할 때 유용하게 사용된다.

<인수 확인>
1. 자바스크립트의 함수는 매개변수와 인수의 개수가 일치하는지 확인x
2. 자바스크립트는 동적 타입 언어이므로 매개변수의 타입을 지정할 수 없다.

<이상적인 함수>
이상적인 함수는 한 가지 일만 해야 하며 매개변수는 가급적 작게 만드는 것이 좋다. 
매개변수는 3개를 넘지 않는 것이 좋다.

<반환문 : return>
1. 반환문은 함수의 실행을 중단하고 함수를 빠져나간다.
    반환문 이후의 문장은 무시된다.
2. 반환문은 return 뒤에 오는 식을 평가해 반환환다.
    이것이 없으면 undefined가 나온다.
3. 반환문이 꼭 있어야 할 필요는 없다. 

<즉시 실행 함수>
즉시 실행 함수는 함수 정의와 동시에 즉시 호출되는 함수를 말한다.
즉시 실행 함수는 단 한번만 호출되며 다시 호출할 수 없다.
1.익명 함수를 쓰는 것이 일반적이다.
2.반드시()연산자로 감싸야 한다.
(function(){
    ...
}());
3.즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있고, 인수를 전달할 수도 있다.

4. 재귀 함수 : 자기 자신을 호출하는 함수
반복문 대신 사용할 수 있다.


