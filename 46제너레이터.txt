제너레이터 : ES6에서 도입되었다.
1. 제너레이터 함수는 함수 호출자에게 함수 실행의 제어권을 양도 가능
2. 재너레이터 함수는 함수 호출자와 함수의 상태를 주고받을 수 있다.
3. 제너레이터 함수를 호풀하면 제너레이터 객체를 반환한다.

제너레이터는 비동기 프로그래밍에서 유용하며, 특히 데이터를 스트리밍하거나 대규모 데이터 집합에서 조작을 수행할 때 
유용하다. 예를 들어, 서버에서 클라이언트에 데이터를 전송하고 싶을 때, 제너레이터를 사용하여 데이터를 스트리밍하고 전송할 수 있다. 
또한 반복가능한 객체를 생성하고 조작하는 작업을 수행하는 데 사용 가능 .

제너레이터 함수는 function* 키워드로 선언한다

제너레이터 함수 선언문
function* getDecFunc(){
    yield 1;
}
제너레이터 함수 표현식
const genExpFunc = function*(){
    yield 1;
};
제너레이터 메서드
const obj = {
    *genObjMethod(){
        yield 1
    }
}
제너레이터 클래스 메서드
class MyClass{
    *genClsMethod(){
        yield 1;
    }
}

* 의 위치는 function 키워드와 함수 이름 사이라면 어디든지 상관없다.
일관성 유지를 위해 function 키워드 바로 뒤에 붙이는 것을 권장한다. 

function* genFunc() {yeild 1};

제너레이터 함수는 화살표 함수로 정의할 수 없다
제너레이터 함수는 new 연산자와 함께 생성자 함수로 호출할 수 없다.

제너레이터 객체

제너레이터 함수를 호출하면 일반 함수처럼 함수 코드 블록을 실행하는 것이 아니라 제너레이터 객체를 생성해 
반환한다. 제너레이터 함수가 반환한 제너레이터 객체는 이터러블이면서 동시에 이터레이터이다. 

p.878
비동기 처리
제너레이터 함수는 next메서드와 yield 표현식을 통해 함수 호출자와 함수의 상태를 주고받을 수 있다.
이러한 특성을 활용하면 프로미스를 사용한 비동기 처리를 동기 처리처럼 구현할 수 있다.
다시 말해, 프로미스 후속 처리 메서드 then/catch/finally 없이 비동기처리 결과를 반환하도록 
구현할 수 있다. 


